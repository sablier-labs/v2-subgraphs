enum ActionCategory {
  Claim
  Clawback
  Create
  TransferAdmin
}

enum CampaignCategory {
  Instant
  LockupDynamic
  LockupLinear
  LockupTranched
}

type Action {
  "unique identifier resolving to transaction hash concatenated with the log index (there may be multiple actions per tx) and the chainId"
  id: String!

  "transaction details: block number"
  block: BigInt!
  "category of action e.g. Create or Clawback"
  category: ActionCategory!
  "hardcoded chain id"
  chainId: BigInt!
  "contract through which the stream actions has been triggered"
  campaign: Campaign!
  "transaction details: hash"
  hash: Bytes!
  "address that triggered the transaction"
  from: Bytes!

  "unique global id tracked by the indexer watcher (resets for every chain)"
  subgraphId: BigInt!
  "transaction details: timestamp"
  timestamp: BigInt!

  "claim action data: stream identifier as constructed in the lockup subgraph - origin contract address concatenated with the chainId and the tokenId"
  claimStreamId: String
  "claim action data: native stream id"
  claimTokenId: BigInt
  "claim action data: amount"
  claimAmount: BigInt
  "claim action data: recipient index"
  claimIndex: BigInt
  "claim action data: recipient index"
  claimRecipient: Bytes

  "clawback action data: amount"
  clawbackAmount: BigInt
  "clawback action data: amount"
  clawbackFrom: Bytes
  "clawback action data: amount"
  clawbackTo: Bytes

  "amount, records the fee paid for certain actions, in base asset (e.g. claim is payable >V23)"
  fee: BigInt
}

type Activity {
  "unique identifier resolving to the string 'activity' concatenated with the campaign id and the day of the snapshot"
  id: String!
  "campaign the activity (day) is linked to"
  campaign: Campaign!

  "timestamp for the start of the day"
  timestamp: BigInt!
  "day index (UNIX time / 24 * 60 * 60)"
  day: BigInt!

  "amount claimed during the day"
  amount: BigInt!
  "number of claims completed during the day"
  claims: BigInt!
}

type Asset {
  "unique identifier resolving to the ERC20 asset/token address, concatenated with the chainId"
  id: String!

  "address of the ERC20 asset/token"
  address: Bytes!
  "hardcoded chain id"
  chainId: BigInt!
  "decimals of the ERC20 asset/token"
  decimals: BigInt!
  "name of the ERC20 asset/token"
  name: String!
  "symbol of the ERC20 asset/token"
  symbol: String!

  "campaigns that rely on this asset/token"
  campaigns: [Campaign!]! @derivedFrom(field: "asset")
}

type Tranche {
  "unique id resolving to campaign id concatenated with the position of the tranche"
  id: String!

  "position of the tranche inside the array"
  position: BigInt!
  "campaign upon which the tranche is used"
  campaign: Campaign!
  "percentage resolving to the percentage of value streamed during this tranche"
  percentage: BigInt!
  "timestamp resolving to the duration of the tranche"
  duration: BigInt!

  "derived percentage resoling to the total amount in percentages streamed until the start of the timestamp"
  startPercentage: BigInt!
  "derived percentage resoling to the total amount in percentages streamed until the end of the timestamp"
  endPercentage: BigInt!

  "duration accrued at the end of the tranche"
  endDuration: BigInt!
  "timestamp resolving to the duration accrued at the start of the tranche"
  startDuration: BigInt!
}

type Campaign {
  "unique identifier resolving to the contract address concatenated with the chain id"
  id: String!
  "unique global id tracked by the indexer watcher (resets for every chain)"
  subgraphId: BigInt!
  "address of the campaign"
  address: Bytes!

  "underlying asset"
  asset: Asset!
  "factory producing the campaign"
  factory: Factory!
  "hardcoded chain id"
  chainId: BigInt!
  "transaction hash for the campaign creation"
  hash: Bytes!
  "timestamp of the campaign creation (for sorting reasons)"
  timestamp: BigInt!
  "category of the produced streams e.g. LockupLinear or LockupDynamic"
  category: CampaignCategory!

  "address of the campaign admin, entitled to clawback"
  admin: Bytes!
  "address of the lockup contract through which streams will be created"
  lockup: Bytes!
  "merkle root"
  root: Bytes!
  "flag showing if the campaign expires or is forever claimable"
  expires: Boolean!
  "time at which the campaign expires and clawback is enabled, if the expires flag is true"
  expiration: BigInt
  "name assigned as the campaign title"
  name: String!
  "name generated by our systems, derived from the user-provided name or generated from scratch for <V22"
  nickname: String!

  "ipfs content identifier for the list of recipients and other static details"
  ipfsCID: String!
  "funds required for the entire campaign to conclude"
  aggregateAmount: BigInt!
  "total number of recipients"
  totalRecipients: BigInt!

  "action in which the campaign underwent a clawback, if it was supposed to expire"
  clawbackAction: Action
  "timestamp for the when the campaign underwent a clawback"
  clawbackTime: BigInt

  "total claimed amount up to this point"
  claimedAmount: BigInt!
  "number of claims requested up to this point"
  claimedCount: BigInt!

  "extended version of the lockup contracts, prefixed with a '2' (e.g. 'V20`, `V21`, `V22`)"
  version: String!
    "persisted fee for this campaign"
  fee: BigInt!

  # Stream: General

  "total duration for produced streams"
  streamTotalDuration: BigInt!
  "flag showing the *initial* cancelability of the produced streams (making it false is a one-way trip, tracked in the lockup subgraph)"
  streamCancelable: Boolean!
  "flag showing the transferability of the produced streams"
  streamTransferable: Boolean!
  "optional label to define the stream shape"
  streamShape: String!

  # Stream: Lockup Linear

  "flag showing if the produced stream has a cliff, only available on linear streams"
  streamCliff: Boolean!
  "timestamp for the start of the cliff, if there's a streamCliff, only available on linear streams"
  streamCliffDuration: BigInt!
  "percentage (from total) to be claimed when the stream cliff is reached, custom for > V23, proportional for early versions < V23"
  streamCliffPercentage: BigInt!

  "flag showing if the produced stream has an initial unlock, only available on linear streams"
  streamInitial: Boolean!
  "percentage (from total) to be initially unlocked at the start of the stream, zero for < V23"
  streamInitialPercentage: BigInt!

  "flag showing if the produced stream has a preset start date or not - starts at claim"
  streamStart: Boolean!
  "moment at which the stream starts, null for < V23 as it coincides with the date of claim"
  streamStartTime: BigInt!

  # Stream: Lockup Tranched

  "a set of tranches with unlock percentages instead of concrete amounts, only available on tranched streams"
  streamTranches: [Tranche!]! @derivedFrom(field: "campaign")
  "actions triggered in the context of this campaign"
  actions: [Action!]! @derivedFrom(field: "campaign")
  "list of daily activity snapshots for days with 1+ events"
  activities: [Activity!]! @derivedFrom(field: "campaign")
}

type Factory {
  "unique identifier resolving to contract address, concatenated to the chainId"
  id: String!

  "hardcoded alias, resolved by replacing the contract address from the id with the contract alias"
  alias: String!
  "address of the contract"
  address: Bytes!
  "hardcoded chain id"
  chainId: BigInt!

  "extended version of the lockup contracts, prefixed with a '2' (e.g. 'V20`, `V21`, `V22`)"
  version: String!

  "list of campaigns"
  campaigns: [Campaign!]! @derivedFrom(field: "factory")
}

type Watcher {
  "unique identifier for the watcher, resolving to the chainId - there is only one watcher for the entire subgraph"
  id: String!
  "hardcoded chain id"
  chainId: BigInt!
  "global index for actions"
  actionIndex: BigInt!
  "global index for campaigns"
  campaignIndex: BigInt!
  "flag that defines the initialization status of the subgraph"
  initialized: Boolean!
  "list of logs, for debugging purposes"
  logs: [String!]!
}
